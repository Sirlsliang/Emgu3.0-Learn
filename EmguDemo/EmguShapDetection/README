  这个工程主要分为三个部分
  一、
    ImageBoxTest
      主要是掌握C#中文件夹加载框（OpenFileDialog）的基础使用。以及Emgu中创建并显示新图像的方式。
  二、
    CameraCapture
      这个主要使用了文档中提供的方法开启摄像头，但是自己开启时摄像头开启，图像没有正确显示。这个留在以后继续研究

  三、
    ShapeDetection
      本文重点，主要是根据文档实现了图片中圆形、线及三角形和长方形的检测
      主要用到的函数分析：
        1、CvInvoke.CvtColor(srcImage, uImage, ColorConversion.Bgr2Gray);
          这个函数主要用来进行颜色空间的转换。
        2、  CvInvoke.PyrDown() 和 CvInvoke.PyrUp()
          利用图像金字塔中的高斯金字塔对图像及进行采样。
            PyrDown:缩小过程，缩小为原来的四分之一。
            PyrUp  ：放大过程，放大为原来的四分之一。
              利用卷积可以对图像进行模糊处理、边缘检测。卷积就是对图像的每一个像素点，计算它的领域像素的和与滤波器矩阵对应元素的乘积然后再加起来作为该像素的位置的值。
      　３、CvInvoke.HoughCircles();
            利用霍夫变换（原始坐标系下的点对应了参数坐标系下的一条直线，参数坐标系下的一条直线，对应了原始坐标系下的一个点，
        原始坐标系下呈现直线的所有点，他们的斜率和截距相同，所有它们在参数坐标系下应位于同一个点）检测圆形。
            参数：
                a、输入图像（去噪后的灰度图）
                b、只实现了Grandient（渐变、梯度变化曲线）选项
                c、待查
                d、检测到的圆之间的最小距离
                e、（可选）Canny边缘检测时指定的参数。在Grandient选项下，传入的值为Canny边缘检测中较大的那个值
                f、（可选）待查
                g、（可选）可检测的最小圆的半径
            返回值：
              CircleF[]: 圆类的数组。
        4、CvInvoke.Canny()
            Canny边缘检测，图像的边缘检测主要是图像的灰度变化的度量、检测和定位。
            彩色图->灰度图->图像平滑（去噪声、高斯滤波）->寻找图像中的强度梯度->非极大值抑制（排除边缘像素）->滞后阈值（高阈值：某一像素位置的幅值超过高阈值保留为边缘像素
            低于低阈值被排除，某一像素在两个阈值之间，该像素连接到一个高阈值的像素被保留。推荐高低阈值比在2：1到3：1之间）
            参数分析：
              a、输入图像（去噪后的灰度图）
              b、输入图像（输入二进制的图）
              c、第一个阈值(高阈值)?
              d、第二个阈值(低阈值)?
      5、CvInvoke.HoughLinesP()
          利用霍夫算法检测线。
          参数：
            a、输入图像（经过Canny边缘算法处理过后的二分图像）
            b、距离解析度（在多少距离内的点都算）？
            c、角度解析度（弧度表示，小于该角度）
            d、累加器值得上限，只有哪些大于该值的点才可以属于一条线（具体的查看霍夫检测算法）？
            e、比该值小的就丢弃
            f、线之间所允许的最大距离
          返回值：
            LineSegment2D[]:线类的数组
      6、CvInvoke.FindContours()
          寻找二值图像中的轮廓线。
          参数：
            a、二值图像
            b、轮廓数据（VectorOfVectorOfPoint:向量点的向量，是一个类，但是有Size属性，也可和数组似的直接访问其中存储的值（VectorOfPoint））
            c、图像的拓扑信息
            d、图像的获取模式
            e、值的近似方法？
          没有返回值。所有的值都存储在轮廓数据中
      7、CvInvoke.ApproxPolyDP():
          根据指定的精度找出近似的多边形
          参数：
            a、轮廓信息（VectorofPoint）
            b、轮廓信息（VectorofPoint）
            c、范围限制
            d、是否闭合（true|false）
      8、CvInvoke.ArcLength()
        计算轮廓边界线的周长或曲线长度
          参数：
            a、轮廓信息（VectorOfPoint）
            c、是否闭合(true|false)
      9、CvInvoke.ContourArea()
        计算轮廓内的面积
          参数：
            a、轮廓信息（VectorOfPoint）
            b、待查
      10、CvInvoke.MinAreaRect():
        根据数据点找边界
          参数：
            a、轮廓信息（VectorofPoint）
      11、所用到的类
        Triangle2DF：三角形
        RotatedRect：矩形
      12、
        VectorOfVectorOfPoint
        VectorOfPoint
          这是两个类，VectorOfVectorOfPoint 类是VectorOfPoint类 的集合。可以直接使用类似数组取值的方法取出。
          VectorofPoint（翻译为向量点？）这个类存在的意义？
总结：
  1、所有的检测都是以去除了噪声的灰度图或者二进制图（是去除噪声的灰度图转化的）为基础的
  2、线（LineSegment2D）和圆（CircleF）直接就可以根据霍夫检测
  3、多边形就需要依靠边等信息的检测来依次进行分类
    eg： 封闭的曲线->确定面积->轮廓的尺寸数->转换为对边的处理
  4、有一些函数直接就可以使用该类自带的函数进行处理。
